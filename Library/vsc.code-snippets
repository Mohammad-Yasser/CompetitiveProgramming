{
	"DSU": {
		"prefix": "/DSU",
		"body": [
			"struct DSU {",
			"  int parent[N];",
			"  void init() {",
			"    for (int i = 0; i < N; ++i) {",
			"      parent[i] = i;",
			"    }",
			"  }",
			"  int getRoot(int x) {",
			"    if (parent[x] == x) return x;",
			"    return parent[x] = getRoot(parent[x]);",
			"  }",
			"  void join(int x, int y) {",
			"    x = getRoot(x);",
			"    y = getRoot(y);",
			"    parent[x] = y;",
			"  }",
			"};"
		],
		"description": "DSU"
	},
	"Power": {
		"prefix": "/power",
		"body": [
			"int power(int base, int p) {",
			"  if (p == 0) return 1;",
			"  int res = power(base, p / 2);",
			"  res = 1LL * res * res % MOD;",
			"  if (p & 1) {",
			"    res = 1LL * res * base % MOD;",
			"  }",
			"  return res;",
			"}",
			""
		],
		"description": "Power"
	},
	"BIT Single Update": {
		"prefix": "/BIT",
		"body": [
			"",
			"template <class INT, int nLeaves>",
			"struct BIT {",
			"  const int kMaxSize = 1 << (int)ceil(log2(nLeaves + 1e-9));",
			"  vector<INT> arr;",
			"  INT size = 0;",
			"",
			"  BIT() { arr.resize(kMaxSize); }",
			"",
			"  INT get(int i) {",
			"    i++;",
			"    INT r = 0;",
			"    while (i) {",
			"      r += arr[i - 1];",
			"      i -= i & -i;",
			"    }",
			"    return r;",
			"  }",
			"",
			"  INT get(int l, int r) {",
			"    if (r < l) return 0;",
			"    if (l == 0) return get(r);",
			"    return get(r) - get(l - 1);",
			"  }",
			"",
			"  void add(int i, INT val = 1) {",
			"    size += val;",
			"    i++;",
			"    while (i <= kMaxSize) {",
			"      arr[i - 1] += val;",
			"      i += i & -i;",
			"    }",
			"  }",
			"",
			"  // Finds element at index ind.",
			"  int find(INT ind) {",
			"    int s = 0;",
			"    int m = kMaxSize >> 1;",
			"    while (m) {",
			"      if (arr[s + m - 1] < ind) ind -= arr[(s += m) - 1];",
			"      m >>= 1;",
			"    }",
			"    return s;",
			"  }",
			"  int lower_bound(int x) { return find(get(x - 1) + 1); }",
			"  void insert(int x) { add(x, 1); }",
			"  void erase(int x) { add(x, -1); }",
			"};",
			""
		],
		"description": "BIT Single Update"
	},
	"Log2": {
		"prefix": "/Log2",
		"body": "__lg(",
		"description": "Integer Log 2"
	},
	"buildFactorial()": {
		"prefix": "/buildFactorial",
		"body": [
			"const int MOD = 998244353;",
			"const int FN = 77;",
			"int fact[FN];",
			"",
			"void buildFactorial() {",
			"  fact[0] = 1;",
			"  inv_fact[0] = 1;",
			"  for (int i = 1; i < FN; ++i) {",
			"    fact[i] = 1LL * i * fact[i - 1] % MOD;",
			"    inv_fact[i] = modInverse(fact[i]);",
			"  }",
			"}",
			""
		],
		"description": "buildFactorial()"
	},
	"modInverse": {
		"prefix": "/modInverse",
		"body": [
			"int modInverse(int x) { return power(x, MOD - 2); }"
		],
		"description": "modInverse"
	},
	"countDivisors": {
		"prefix": "/countDivisors",
		"body": [
			"int countDivisors(Long d) {",
			"  int res = 0;",
			"  for (int i = 1; 1LL * i * i <= d; ++i) {",
			"    if (d % i == 0) {",
			"      ++res;",
			"      res += (i != d / i);",
			"    }",
			"  }",
			"  return res;",
			"}"
		],
		"description": "countDivisors"
	},
	"buildPrimeFactors()": {
		"prefix": "/buildPrimeFactors",
		"body": [
			"",
			"vector<Long> prime_factors;",
			"",
			"void buildPrimeFactors(Long d) {",
			"  for (Long i = 2; i * i <= d; ++i) {",
			"    if (d % i != 0) continue;",
			"    prime_factors.emplace_back(i);",
			"    while (d % i == 0) {",
			"      d /= i;",
			"    }",
			"  }",
			"  if (d != 1) {",
			"    prime_factors.emplace_back(d);",
			"  }",
			"}"
		],
		"description": "buildPrimeFactors()"
	},
	"Gauss Xor": {
		"prefix": "/GaussXor",
		"body": [
			"",
			"bool isSet(Long n, int b) {",
			"  return (n >> b) & 1LL;",
			"}",
			"",
			"void printRow(int x) {",
			"  cout << bitset<5>(x).to_string() << endl;",
			"}",
			"",
			"void printMat(const vector<Long>& mat) {",
			"  for (auto& x : mat) {",
			"    printRow(x);",
			"  }",
			"}",
			"",
			"vector<Long> getRREF(const vector<Long>& mat) {",
			"  vector<Long> res = mat;",
			"  int rank = 0;",
			"  for (int row = 0, col = 63; row < res.size() && col >= 0; --col) {",
			"    for (int i = row; i < res.size(); ++i) {",
			"      if (isSet(res[i], col)) {",
			"        swap(res[row], res[i]);",
			"        break;",
			"      }",
			"    }",
			"    if (!isSet(res[row], col)) continue;",
			"    ++rank;",
			"    for (int i = 0; i < res.size(); ++i) {",
			"      if (i == row) continue;",
			"      if (isSet(res[i], col)) {",
			"        res[i] ^= res[row];",
			"      }",
			"    }",
			"",
			"    ++row;",
			"  }",
			"",
			"  return res;",
			"}",
			"",
			"int getRank(const vector<Long>& mat) {",
			"  int res = 0;",
			"  for (auto& x : mat) {",
			"    res += (x != 0);",
			"  }",
			"  return res;",
			"}",
			""
		],
		"description": "Gauss Xor"
	},
	"Compress": {
		"prefix": "/compress",
		"body": [
			"template <class T>",
			"vector<T> compress(const vector<T>& v) {",
			"  vector<T> sorted_v = v;",
			"  sort(all(sorted_v));",
			"  vector<T> res = v;",
			"  for (auto& x : res) {",
			"    x = lower_bound(all(sorted_v), x) - begin(sorted_v) + 1;  // 1-based.",
			"  }",
			"  return res;",
			"}"
		],
		"description": "Compress"
	},
	"Sparse Table": {
		"prefix": "/SparseTable",
		"body": [
			"template <typename T, class F = function<T(const T&, const T&)>>",
			"struct SparseTable {",
			"  int n;",
			"  vector<vector<T>> sp;",
			"  F func;",
			"",
			"  SparseTable() {}",
			"",
			"  void init(const vector<T>& a, const F& f) {",
			"    func = f;",
			"    n = static_cast<int>(a.size());",
			"    int max_log = 32 - __builtin_clz(n);",
			"    sp.resize(max_log);",
			"    sp[0] = a;",
			"    for (int j = 1; j < max_log; ++j) {",
			"      sp[j].resize(n - (1 << j) + 1);",
			"      for (int i = 0; i <= n - (1 << j); ++i) {",
			"        sp[j][i] = func(sp[j - 1][i], sp[j - 1][i + (1 << (j - 1))]);",
			"      }",
			"    }",
			"  }",
			"",
			"  T query(int l, int r) const {",
			"    int lg = 32 - __builtin_clz(r - l + 1) - 1;",
			"    return func(sp[lg][l], sp[lg][r - (1 << lg) + 1]);",
			"  }",
			"",
			"  // Not quite tested.",
			"  // T query(int l, int r) const {",
			"  //   int lg = 32 - __builtin_clz(r - l + 1) - 1;",
			"  //   if ((1 << lg) == r - l + 1) {",
			"  //     return sp[lg][l];",
			"  //   }",
			"  //   return func(sp[lg][l], query(l + (1 << lg), r));",
			"  // }",
			"};",
			"",
			"SparseTable<int> sparse_table;",
			"sparse_table.init(v, [](int x, int y) { return __gcd(x, y); });"
		],
		"description": "Sparse Table"
	},
	"log10": {
		"prefix": "/log10",
		"body": [
			"int _log10(int x) {",
			"  if (x == 0) return 0;",
			"  return 1 + _log10(x / 10);",
			"}"
		],
		"description": "log10"
	},
	"Iterative Segment Tree": {
		"prefix": "/segmentTreeIterative",
		"body": [
			"struct SegmentTree {",
			"  vector<int> tree;",
			"  SegmentTree() : tree(3 * N, 0) {}",
			"  void modify(int p, int value) {  // set value at position p",
			"    for (tree[p += N] = value; p > 1; p >>= 1)",
			"      tree[p >> 1] = max(tree[p], tree[p ^ 1]);",
			"  }",
			"  // r exclusive",
			"  int query(int l, int r) {",
			"    int res = 0;",
			"    for (l += N, r += N; l < r; l >>= 1, r >>= 1) {",
			"      if (l & 1) res = max(res, tree[l++]);",
			"      if (r & 1) res = max(res, tree[--r]);",
			"    }",
			"    return res;",
			"  }",
			"} seg_tree;"
		],
		"description": "Iterative Segment Tree"
	},
	"isSquare": {
		"prefix": "/isSquare",
		"body": [
			"bool isCCWSquare(const vector<P>& points) {",
			"  for (int i = 0; i < 4; ++i) {",
			"    int before = (i + 3) % 4;",
			"    int after = (i + 1) % 4;",
			"    int curr = i;",
			"    if (points[after].rotateCCW90Around(points[curr]) != points[before])",
			"      return false;",
			"  }",
			"  return true;",
			"}",
			"",
			"// Returns false if degenerate.",
			"// Doesn't do multiplication, so can work with long long.",
			"bool isSquare(vector<P> points) {",
			"  if (points[0] == points[1] || points[0] == points[2] ||",
			"      points[0] == points[3])",
			"    return false;  // Degenerate",
			"",
			"  for (int i = 0; i < 3; ++i) {",
			"    if (isCCWSquare(points)) return true;",
			"    swap(points[2], points[3]);",
			"    if (isCCWSquare(points)) return true;",
			"    swap(points[1], points[2]);",
			"  }",
			"  return false;",
			"}"
		],
		"description": "isSquare"
	},
	"Geometry": {
		"prefix": "/Geometry",
		"body": [
			"",
			"typedef long double Double;",
			"",
			"const Double EPS = 1e-10;",
			"",
			"enum Relation { LESS_THAN, EQUAL, GREATER_THAN };",
			"",
			"bool areEqual(Double x, Double y, Double eps = EPS) {",
			"  auto diff = abs(x - y);",
			"  x = abs(x), y = abs(y);",
			"  if (diff <= eps) return true;",
			"  if (min(x, y) <= eps) return false;",
			"  return diff <= eps * max(x, y);",
			"}",
			"",
			"bool isZero(Double x, Double eps = EPS) { return abs(x) <= eps; }",
			"",
			"int compareDoubles(Double x, Double y, Double eps = EPS) {",
			"  if (areEqual(x, y, eps)) return Relation::EQUAL;",
			"  if (x < y) return Relation::LESS_THAN;",
			"  return Relation::GREATER_THAN;",
			"}",
			"",
			"template <class T>",
			"struct Point {",
			"  typedef Point P;",
			"  T x = 0, y = 0;",
			"  Point(T x, T y) : x(x), y(y) {}",
			"  Point() {}",
			"  pair<T, T> to_pair() const { return make_pair(x, y); }",
			"  Point operator+(const Point& p) const { return Point{x + p.x, y + p.y}; }",
			"  Point operator-(const Point& p) const { return Point{x - p.x, y - p.y}; }",
			"  Point operator*(T c) const { return Point(x * c, y * c); }",
			"  Point operator/(T c) const { return Point(x / c, y / c); }",
			"  bool operator<(const Point& p) const {",
			"    return (*this) != p && to_pair() < p.to_pair();",
			"  }",
			"  bool operator>(const Point& p) const { return (*this) != p && !(*this < p); }",
			"  bool operator==(const Point& p) const {",
			"    return isZero(this->x - p.x) && isZero(this->y - p.y);",
			"  }",
			"  bool operator!=(const Point& p) const { return !(*this == p); }",
			"  T cross(const P& p) const { return x * p.y - y * p.x; }",
			"  T cross(const P& a, const P& b) const { return (a - *this).cross(b - *this); }",
			"  T dot(const P& p) const { return x * p.x + y * p.y; }",
			"  P midPoint(const P& p) const { return ((*this) + p) / 2; }",
			"  P getVector(const P& p) const { return p - (*this); }",
			"  T dist2(const P& p) const { return getVector(p).length2(); }",
			"  T length2() const { return (*this).dot(*this); }",
			"  Double dist(const P& p) const { return sqrt(dist2(p)); }",
			"  P rotateCCW90() const { return P(-y, x); }",
			"  P rotateCCW90Around(const P& p) const {",
			"    return p + p.getVector(*this).rotateCCW90();",
			"  }",
			"  P rotateCCW(Double angle) const {",
			"    return Point(x * cos(angle) - y * sin(angle),",
			"                 x * sin(angle) + y * cos(angle));",
			"  }",
			"",
			"  // Project point onto line through a and b (assuming a != b).",
			"  P projectOnLine(const P& a, const P& b) const {",
			"    P ab = a.getVector(b);",
			"    P ac = a.getVector(*this);",
			"    return a + ab * ac.dot(ab) / a.dist2(b);",
			"  }",
			"",
			"  // Project point c onto line segment through a and b (assuming a != b).",
			"  P projectOnSegment(const P& a, const P& b) const {",
			"    P ab = a.getVector(b);",
			"    P ac = a.getVector(c);",
			"",
			"    Double r = dot(ac, ab), d = a.dist2(b);",
			"    if (r < 0) return a;",
			"    if (r > d) return b;",
			"",
			"    return a + ab * r / d;",
			"  }",
			"",
			"  P reflectAroundLine(const P& a, const P& b) const {",
			"    return projectOnLine(a, b) * 2 - (*this);",
			"  }",
			"};",
			"",
			"typedef Point<Double> Vector;",
			"typedef Point<Double> P;",
			"typedef array<P, 2> Segment;",
			"",
			"template <class T>",
			"istream& operator>>(istream& is, Point<T>& p) {",
			"  return is >> p.x >> p.y;",
			"}",
			"",
			"template <class T>",
			"ostream& operator<<(ostream& os, Point<T>& p) {",
			"  return os << p.x << \" \" << p.y;",
			"}"
		],
		"description": "Geometry"
	},
	"Hash Table": {
		"prefix": "/hashMap",
		"body": [
			"const int RANDOM =",
			"    chrono::high_resolution_clock::now().time_since_epoch().count();",
			"struct chash {  // To use most bits rather than just the lowest ones:",
			"  const uint64_t C = Long(4e18 * acos(0)) | 71;  // large odd number",
			"  Long operator()(Long x) const { return __builtin_bswap64((x ^ RANDOM) * C); }",
			"};",
			"__gnu_pbds::gp_hash_table<Long, int, chash> ht({}, {}, {}, {}, {1 << 16});"
		],
		"description": "Hash Table"
	},
	"Maximize": {
		"prefix": "/maximize",
		"body": [
			"template <typename T>",
			"void maximize(T& x, const T& y) {",
			"  x = max(x, y);",
			"}"
		],
		"description": "Maximize"
	},
	"Minimize": {
		"prefix": "/minimize",
		"body": [
			"template <typename T>",
			"void minimize(T& x, const T& y) {",
			"  x = min(x, y);",
			"}"
		],
		"description": "Minimize"
	},
	"Segment Tree": {
		"prefix": "/SegmentTree",
		"body": [
			"template <typename T, typename U>",
			"struct SegmentTree {",
			"  int S, H;",
			" ",
			"  T zero;",
			"  vector<T> value;",
			" ",
			"  U noop;",
			"  vector<bool> dirty;",
			"  vector<U> prop;",
			" ",
			"  SegmentTree<T, U>(int _S = 1, T _zero = T(), U _noop = U()) {",
			"    zero = _zero, noop = _noop;",
			"    for (S = 1, H = 1; S < _S;) S *= 2, H++;",
			" ",
			"    value.resize(2 * S, zero);",
			"    dirty.resize(2 * S, false);",
			"    prop.resize(2 * S, noop);",
			"  }",
			" ",
			"  void set_leaves(vector<T>& leaves) {",
			"    copy(leaves.begin(), leaves.end(), value.begin() + S);",
			" ",
			"    for (int i = S - 1; i > 0; i--) value[i] = value[2 * i] + value[2 * i + 1];",
			"  }",
			" ",
			"  void apply(int i, const U& update) {",
			"    value[i] = update(value[i]);",
			"    if (i < S) {",
			"      prop[i] = prop[i] + update;",
			"      dirty[i] = true;",
			"    }",
			"  }",
			" ",
			"  void rebuild(int i) {",
			"    for (int l = i / 2; l; l /= 2) {",
			"      T combined = value[2 * l] + value[2 * l + 1];",
			"      value[l] = prop[l](combined);",
			"    }",
			"  }",
			" ",
			"  void propagate(int i) {",
			"    for (int h = H; h > 0; h--) {",
			"      int l = i >> h;",
			" ",
			"      if (dirty[l]) {",
			"        apply(2 * l, prop[l]);",
			"        apply(2 * l + 1, prop[l]);",
			" ",
			"        prop[l] = noop;",
			"        dirty[l] = false;",
			"      }",
			"    }",
			"  }",
			" ",
			"  void upd(int i, int j, const U& update) {",
			"    i += S, j += S;",
			"    propagate(i), propagate(j);",
			" ",
			"    for (int l = i, r = j; l <= r; l /= 2, r /= 2) {",
			"      if ((l & 1) == 1) apply(l++, update);",
			"      if ((r & 1) == 0) apply(r--, update);",
			"    }",
			" ",
			"    rebuild(i), rebuild(j);",
			"  }",
			" ",
			"  T query(int i, int j) {",
			"    i += S, j += S;",
			"    propagate(i), propagate(j);",
			" ",
			"    T res_left = zero, res_right = zero;",
			"    for (; i <= j; i /= 2, j /= 2) {",
			"      if ((i & 1) == 1) res_left = res_left + value[i++];",
			"      if ((j & 1) == 0) res_right = value[j--] + res_right;",
			"    }",
			"    return res_left + res_right;",
			"  }",
			"};",
			" ",
			"struct Node {",
			"  Node operator+(const Node& right) const {",
			"    Node res = right;",
			"    return res;",
			"  }",
			"};",
			" ",
			"struct Update {",
			"  Update() {}",
			"  Update operator+(const Update& right) const {",
			"    Update res = right;",
			"    return res;",
			"  }",
			"  Node operator()(const Node& node) const {",
			"    Node res = node;",
			"    return res;",
			"  }",
			"};"
		],
		"description": "Segment Tree"
	},
	"Transpose Grid": {
		"prefix": "/transpose",
		"body": [
			"template <typename T>",
			"vector<vector<T>> transpose(const vector<vector<T>>& grid) {",
			"  int length = grid[0].size();",
			"  int width = grid.size();",
			" ",
			"  vector<vector<T>> res(length, vector<T>(width));",
			"  for (int i = 0; i < length; ++i) {",
			"    for (int j = 0; j < width; ++j) {",
			"      res[i][j] = grid[j][i];",
			"    }",
			"  }",
			"  return res;",
			"}"
		],
		"description": "Transpose Grid"
	},
	"Print Grid": {
		"prefix": "/printVector",
		"body": [
			"template <typename T>",
			"void print(const vector<T>& v, const string& sep = \"\\n\") {",
			"  for (auto& x : v) {",
			"    cout << x << sep;",
			"  }",
			"  cout.flush();",
			"}",
			" ",
			"template <typename T>",
			"void print(const vector<vector<T>>& v) {",
			"  for (auto& x : v) {",
			"    print(x, \"\");",
			"    cout << endl;",
			"  }",
			"  cout.flush();",
			"}"
		],
		"description": "Print Grid"
	}
}
