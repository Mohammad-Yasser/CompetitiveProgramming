{
	"DSU": {
		"prefix": "/DSU",
		"body": [
			"struct DSU {",
			"  int parent[N];",
			"  void init() {",
			"    for (int i = 0; i < N; ++i) {",
			"      parent[i] = i;",
			"    }",
			"  }",
			"  int getRoot(int x) {",
			"    if (parent[x] == x) return x;",
			"    return parent[x] = getRoot(parent[x]);",
			"  }",
			"  void join(int x, int y) {",
			"    x = getRoot(x);",
			"    y = getRoot(y);",
			"    parent[x] = y;",
			"  }",
			"};"
		],
		"description": "DSU"
	},
	"Power": {
		"prefix": "/power",
		"body": [
			"int power(int base, int p) {",
			"  if (p == 0) return 1;",
			"  int res = power(base, p / 2);",
			"  res = 1LL * res * res % MOD;",
			"  if (p & 1) {",
			"    res = 1LL * res * base % MOD;",
			"  }",
			"  return res;",
			"}",
			""
		],
		"description": "Power"
	},
	"BIT Single Update": {
		"prefix": "/BIT",
		"body": [
			"",
			"template <class INT, int nLeaves>",
			"struct BIT {",
			"  const int kMaxSize = 1 << (int)ceil(log2(nLeaves + 1e-9));",
			"  vector<INT> arr;",
			"  INT size = 0;",
			"",
			"  BIT() { arr.resize(kMaxSize); }",
			"",
			"  INT get(int i) {",
			"    i++;",
			"    INT r = 0;",
			"    while (i) {",
			"      r += arr[i - 1];",
			"      i -= i & -i;",
			"    }",
			"    return r;",
			"  }",
			"",
			"  INT get(int l, int r) {",
			"    if (r < l) return 0;",
			"    if (l == 0) return get(r);",
			"    return get(r) - get(l - 1);",
			"  }",
			"",
			"  void add(int i, INT val = 1) {",
			"    size += val;",
			"    i++;",
			"    while (i <= kMaxSize) {",
			"      arr[i - 1] += val;",
			"      i += i & -i;",
			"    }",
			"  }",
			"",
			"  // Finds element at index ind.",
			"  int find(INT ind) {",
			"    int s = 0;",
			"    int m = kMaxSize >> 1;",
			"    while (m) {",
			"      if (arr[s + m - 1] < ind) ind -= arr[(s += m) - 1];",
			"      m >>= 1;",
			"    }",
			"    return s;",
			"  }",
			"  int lower_bound(int x) { return find(get(x - 1) + 1); }",
			"  void insert(int x) { add(x, 1); }",
			"  void erase(int x) { add(x, -1); }",
			"};",
			""
		],
		"description": "BIT Single Update"
	},
	"Log2": {
		"prefix": "/Log2",
		"body": "__lg(",
		"description": "Integer Log 2"
	},
	"buildFactorial()": {
		"prefix": "/buildFactorial",
		"body": [
			"const int MOD = 998244353;",
			"const int FN = 77;",
			"int fact[FN];",
			"",
			"void buildFactorial() {",
			"  fact[0] = 1;",
			"  inv_fact[0] = 1;",
			"  for (int i = 1; i < FN; ++i) {",
			"    fact[i] = 1LL * i * fact[i - 1] % MOD;",
			"    inv_fact[i] = modInverse(fact[i]);",
			"  }",
			"}",
			""
		],
		"description": "buildFactorial()"
	},
	"modInverse": {
		"prefix": "/modInverse",
		"body": [
			"int modInverse(int x) { return power(x, MOD - 2); }"
		],
		"description": "modInverse"
	},
	"countDivisors": {
		"prefix": "/countDivisors",
		"body": [
			"int countDivisors(Long d) {",
			"  int res = 0;",
			"  for (int i = 1; 1LL * i * i <= d; ++i) {",
			"    if (d % i == 0) {",
			"      ++res;",
			"      res += (i != d / i);",
			"    }",
			"  }",
			"  return res;",
			"}"
		],
		"description": "countDivisors"
	},
	"buildPrimeFactors()": {
		"prefix": "/buildPrimeFactors",
		"body": [
			"",
			"vector<Long> prime_factors;",
			"",
			"void buildPrimeFactors(Long d) {",
			"  for (Long i = 2; i * i <= d; ++i) {",
			"    if (d % i != 0) continue;",
			"    prime_factors.emplace_back(i);",
			"    while (d % i == 0) {",
			"      d /= i;",
			"    }",
			"  }",
			"  if (d != 1) {",
			"    prime_factors.emplace_back(d);",
			"  }",
			"}"
		],
		"description": "buildPrimeFactors()"
	},
	"Gauss Xor": {
		"prefix": "/GaussXor",
		"body": [
			"",
			"bool isSet(Long n, int b) {",
			"  return (n >> b) & 1LL;",
			"}",
			"",
			"void printRow(int x) {",
			"  cout << bitset<5>(x).to_string() << endl;",
			"}",
			"",
			"void printMat(const vector<Long>& mat) {",
			"  for (auto& x : mat) {",
			"    printRow(x);",
			"  }",
			"}",
			"",
			"vector<Long> getRREF(const vector<Long>& mat) {",
			"  vector<Long> res = mat;",
			"  int rank = 0;",
			"  for (int row = 0, col = 63; row < res.size() && col >= 0; --col) {",
			"    for (int i = row; i < res.size(); ++i) {",
			"      if (isSet(res[i], col)) {",
			"        swap(res[row], res[i]);",
			"        break;",
			"      }",
			"    }",
			"    if (!isSet(res[row], col)) continue;",
			"    ++rank;",
			"    for (int i = 0; i < res.size(); ++i) {",
			"      if (i == row) continue;",
			"      if (isSet(res[i], col)) {",
			"        res[i] ^= res[row];",
			"      }",
			"    }",
			"",
			"    ++row;",
			"  }",
			"",
			"  return res;",
			"}",
			"",
			"int getRank(const vector<Long>& mat) {",
			"  int res = 0;",
			"  for (auto& x : mat) {",
			"    res += (x != 0);",
			"  }",
			"  return res;",
			"}",
			""
		],
		"description": "Gauss Xor"
	},
	"Compress": {
		"prefix": "/compress",
		"body": [
			"template <class T>",
			"vector<T> compress(const vector<T>& v) {",
			"  vector<T> sorted_v = v;",
			"  sort(all(sorted_v));",
			"  vector<T> res = v;",
			"  for (auto& x : res) {",
			"    x = lower_bound(all(sorted_v), x) - begin(sorted_v) + 1;  // 1-based.",
			"  }",
			"  return res;",
			"}"
		],
		"description": "Compress"
	},
	"Sparse Table": {
		"prefix": "/SparseTable",
		"body": [
			"template <typename T, class F = function<T(const T&, const T&)>>",
			"struct SparseTable {",
			"  int n;",
			"  vector<vector<T>> sp;",
			"  F func;",
			"",
			"  SparseTable() {}",
			"",
			"  void init(const vector<T>& a, const F& f) {",
			"    func = f;",
			"    n = static_cast<int>(a.size());",
			"    int max_log = 32 - __builtin_clz(n);",
			"    sp.resize(max_log);",
			"    sp[0] = a;",
			"    for (int j = 1; j < max_log; ++j) {",
			"      sp[j].resize(n - (1 << j) + 1);",
			"      for (int i = 0; i <= n - (1 << j); ++i) {",
			"        sp[j][i] = func(sp[j - 1][i], sp[j - 1][i + (1 << (j - 1))]);",
			"      }",
			"    }",
			"  }",
			"",
			"  T query(int l, int r) const {",
			"    int lg = 32 - __builtin_clz(r - l + 1) - 1;",
			"    return func(sp[lg][l], sp[lg][r - (1 << lg) + 1]);",
			"  }",
			"",
			"  // Not quite tested.",
			"  // T query(int l, int r) const {",
			"  //   int lg = 32 - __builtin_clz(r - l + 1) - 1;",
			"  //   if ((1 << lg) == r - l + 1) {",
			"  //     return sp[lg][l];",
			"  //   }",
			"  //   return func(sp[lg][l], query(l + (1 << lg), r));",
			"  // }",
			"};",
			"",
			"SparseTable<int> sparse_table;",
			"sparse_table.init(v, [](int x, int y) { return __gcd(x, y); });"
		],
		"description": "Sparse Table"
	},
	"log10": {
		"prefix": "/log10",
		"body": [
			"int _log10(int x) {",
			"  if (x == 0) return 0;",
			"  return 1 + _log10(x / 10);",
			"}"
		],
		"description": "log10"
	},
	"Iterative Segment Tree": {
		"prefix": "/segmentTreeIterative",
		"body": [
			"struct SegmentTree {",
			"  vector<int> tree;",
			"  SegmentTree() : tree(3 * N, 0) {}",
			"  void modify(int p, int value) {  // set value at position p",
			"    for (tree[p += N] = value; p > 1; p >>= 1)",
			"      tree[p >> 1] = max(tree[p], tree[p ^ 1]);",
			"  }",
			"  // r exclusive",
			"  int query(int l, int r) {",
			"    int res = 0;",
			"    for (l += N, r += N; l < r; l >>= 1, r >>= 1) {",
			"      if (l & 1) res = max(res, tree[l++]);",
			"      if (r & 1) res = max(res, tree[--r]);",
			"    }",
			"    return res;",
			"  }",
			"} seg_tree;"
		],
		"description": "Iterative Segment Tree"
	},
	"isSquare": {
		"prefix": "/isSquare",
		"body": [
			"bool isCCWSquare(const vector<P>& points) {",
			"  for (int i = 0; i < 4; ++i) {",
			"    int before = (i + 3) % 4;",
			"    int after = (i + 1) % 4;",
			"    int curr = i;",
			"    if (points[after].rotateCCW90Around(points[curr]) != points[before])",
			"      return false;",
			"  }",
			"  return true;",
			"}",
			"",
			"// Returns false if degenerate.",
			"// Doesn't do multiplication, so can work with long long.",
			"bool isSquare(vector<P> points) {",
			"  if (points[0] == points[1] || points[0] == points[2] ||",
			"      points[0] == points[3])",
			"    return false;  // Degenerate",
			"",
			"  for (int i = 0; i < 3; ++i) {",
			"    if (isCCWSquare(points)) return true;",
			"    swap(points[2], points[3]);",
			"    if (isCCWSquare(points)) return true;",
			"    swap(points[1], points[2]);",
			"  }",
			"  return false;",
			"}"
		],
		"description": "isSquare"
	},
	"Geometry Point": {
		"prefix": "/geoPoint",
		"body": [
			"",
			"const Double EPS = 1e-10;",
			"",
			"enum Relation { LESS_THAN, EQUAL, GREATER_THAN };",
			"",
			"bool areEqual(Double x, Double y, Double eps = EPS) {",
			"  auto diff = abs(x - y);",
			"  x = abs(x), y = abs(y);",
			"  if (diff <= eps) return true;",
			"  if (min(x, y) <= eps) return false;",
			"  return diff <= eps * max(x, y);",
			"}",
			"",
			"bool isZero(Double x, Double eps = EPS) { return abs(x) <= eps; }",
			"",
			"int compareDoubles(Double x, Double y, Double eps = EPS) {",
			"  if (areEqual(x, y, eps)) return Relation::EQUAL;",
			"  if (x < y) return Relation::LESS_THAN;",
			"  return Relation::GREATER_THAN;",
			"}",
			"",
			"template <typename T = Double>",
			"struct Point {",
			"  typedef Point P;",
			"  const static P Invalid;",
			"  const static P Origin;",
			"",
			"  T x = 0, y = 0;",
			"  Point(T x, T y) : x(x), y(y) {}",
			"  Point() {}",
			"  pair<T, T> to_pair() const { return make_pair(x, y); }",
			"  Point operator+(const Point& p) const { return Point{x + p.x, y + p.y}; }",
			"  Point operator-(const Point& p) const { return Point{x - p.x, y - p.y}; }",
			"  Point operator*(T c) const { return Point(x * c, y * c); }",
			"  Point operator/(T c) const { return Point(x / c, y / c); }",
			"  bool operator<(const Point& p) const {",
			"    return (*this) != p && to_pair() < p.to_pair();",
			"  }",
			"  bool operator>(const Point& p) const { return (*this) != p && !(*this < p); }",
			"  bool operator==(const Point& p) const {",
			"    return isZero(this->x - p.x) && isZero(this->y - p.y);",
			"  }",
			"  bool operator!=(const Point& p) const { return !(*this == p); }",
			"  T cross(const P& p) const { return x * p.y - y * p.x; }",
			"  T cross(const P& a, const P& b) const { return (a - *this).cross(b - *this); }",
			"  T dot(const P& p) const { return x * p.x + y * p.y; }",
			"  P midPoint(const P& p) const { return ((*this) + p) / 2; }",
			"  P getVector(const P& p) const { return p - (*this); }",
			"  T dist2(const P& p) const { return getVector(p).dist2(); }",
			"  T dist2() const { return (*this).dot(*this); }",
			"  Double dist(const P& p) const { return sqrt(dist2(p)); }",
			"  Double dist() const { return sqrt(dist2()); }",
			"  P rotateCCW90() const { return P(-y, x); }",
			"  P rotateCCW90Around(const P& p) const {",
			"    return p + p.getVector(*this).rotateCCW90();",
			"  }",
			"  P rotateCCW(Double angle) const {",
			"    return Point(x * cos(angle) - y * sin(angle),",
			"                 x * sin(angle) + y * cos(angle));",
			"  }",
			"",
			"  // Project point onto line through a and b (assuming a != b).",
			"  P projectOnLine(const P& a, const P& b) const {",
			"    P ab = a.getVector(b);",
			"    P ac = a.getVector(*this);",
			"    return a + ab * ac.dot(ab) / a.dist2(b);",
			"  }",
			"",
			"  // Project point c onto line segment through a and b (assuming a != b).",
			"  P projectOnSegment(const P& a, const P& b) const {",
			"    P& c = *this;",
			"    P ab = a.getVector(b);",
			"    P ac = a.getVector(c);",
			"",
			"    Double r = dot(ac, ab), d = a.dist2(b);",
			"    if (r < 0) return a;",
			"    if (r > d) return b;",
			"",
			"    return a + ab * r / d;",
			"  }",
			"",
			"  P reflectAroundLine(const P& a, const P& b) const {",
			"    return projectOnLine(a, b) * 2 - (*this);",
			"  }",
			"",
			"  friend istream& operator>>(istream& is, P& p) { return is >> p.x >> p.y; }",
			"",
			"  friend ostream& operator<<(ostream& os, P& p) {",
			"    return os << p.x << \" \" << p.y;",
			"  }",
			"};",
			"",
			"template <typename T>",
			"const Point<T> Point<T>::Invalid = Point<T>(numeric_limits<T>::max(),",
			"                                            numeric_limits<T>::max());",
			"template <typename T>",
			"const Point<T> Point<T>::Origin = Point<T>(0, 0);",
			"",
			"typedef Point<Double> Vector;",
			"typedef Point<Double> P;"
		],
		"description": "Geometry Point"
	},
	"Hash Table": {
		"prefix": "/hashMap",
		"body": [
			"const int RANDOM =",
			"    chrono::high_resolution_clock::now().time_since_epoch().count();",
			"struct chash {  // To use most bits rather than just the lowest ones:",
			"  const uint64_t C = Long(4e18 * acos(0)) | 71;  // large odd number",
			"  Long operator()(Long x) const { return __builtin_bswap64((x ^ RANDOM) * C); }",
			"};",
			"__gnu_pbds::gp_hash_table<Long, int, chash> ht({}, {}, {}, {}, {1 << 16});"
		],
		"description": "Hash Table"
	},
	"Maximize": {
		"prefix": "/maximize",
		"body": [
			"template <typename T>",
			"void maximize(T& x, const T& y) {",
			"  x = max(x, y);",
			"}"
		],
		"description": "Maximize"
	},
	"Minimize": {
		"prefix": "/minimize",
		"body": [
			"template <typename T>",
			"void minimize(T& x, const T& y) {",
			"  x = min(x, y);",
			"}"
		],
		"description": "Minimize"
	},
	"Segment Tree": {
		"prefix": "/SegmentTree",
		"body": [
			"template <typename T, typename U>",
			"struct SegmentTree {",
			"  int S, H;",
			" ",
			"  T zero;",
			"  vector<T> value;",
			" ",
			"  U noop;",
			"  vector<bool> dirty;",
			"  vector<U> prop;",
			" ",
			"  SegmentTree<T, U>(int _S = 1, T _zero = T(), U _noop = U()) {",
			"    zero = _zero, noop = _noop;",
			"    for (S = 1, H = 1; S < _S;) S *= 2, H++;",
			" ",
			"    value.resize(2 * S, zero);",
			"    dirty.resize(2 * S, false);",
			"    prop.resize(2 * S, noop);",
			"  }",
			" ",
			"  void set_leaves(vector<T>& leaves) {",
			"    copy(leaves.begin(), leaves.end(), value.begin() + S);",
			" ",
			"    for (int i = S - 1; i > 0; i--) value[i] = value[2 * i] + value[2 * i + 1];",
			"  }",
			" ",
			"  void apply(int i, const U& update) {",
			"    value[i] = update(value[i]);",
			"    if (i < S) {",
			"      prop[i] = prop[i] + update;",
			"      dirty[i] = true;",
			"    }",
			"  }",
			" ",
			"  void rebuild(int i) {",
			"    for (int l = i / 2; l; l /= 2) {",
			"      T combined = value[2 * l] + value[2 * l + 1];",
			"      value[l] = prop[l](combined);",
			"    }",
			"  }",
			" ",
			"  void propagate(int i) {",
			"    for (int h = H; h > 0; h--) {",
			"      int l = i >> h;",
			" ",
			"      if (dirty[l]) {",
			"        apply(2 * l, prop[l]);",
			"        apply(2 * l + 1, prop[l]);",
			" ",
			"        prop[l] = noop;",
			"        dirty[l] = false;",
			"      }",
			"    }",
			"  }",
			" ",
			"  void upd(int i, int j, const U& update) {",
			"    i += S, j += S;",
			"    propagate(i), propagate(j);",
			" ",
			"    for (int l = i, r = j; l <= r; l /= 2, r /= 2) {",
			"      if ((l & 1) == 1) apply(l++, update);",
			"      if ((r & 1) == 0) apply(r--, update);",
			"    }",
			" ",
			"    rebuild(i), rebuild(j);",
			"  }",
			" ",
			"  T query(int i, int j) {",
			"    i += S, j += S;",
			"    propagate(i), propagate(j);",
			" ",
			"    T res_left = zero, res_right = zero;",
			"    for (; i <= j; i /= 2, j /= 2) {",
			"      if ((i & 1) == 1) res_left = res_left + value[i++];",
			"      if ((j & 1) == 0) res_right = value[j--] + res_right;",
			"    }",
			"    return res_left + res_right;",
			"  }",
			"};",
			" ",
			"struct Node {",
			"  Node operator+(const Node& right) const {",
			"    Node res = right;",
			"    return res;",
			"  }",
			"};",
			" ",
			"struct Update {",
			"  Update() {}",
			"  Update operator+(const Update& right) const {",
			"    Update res = right;",
			"    return res;",
			"  }",
			"  Node operator()(const Node& node) const {",
			"    Node res = node;",
			"    return res;",
			"  }",
			"};"
		],
		"description": "Segment Tree"
	},
	"Transpose Grid": {
		"prefix": "/transpose",
		"body": [
			"template <typename T>",
			"vector<vector<T>> transpose(const vector<vector<T>>& grid) {",
			"  int length = grid[0].size();",
			"  int width = grid.size();",
			" ",
			"  vector<vector<T>> res(length, vector<T>(width));",
			"  for (int i = 0; i < length; ++i) {",
			"    for (int j = 0; j < width; ++j) {",
			"      res[i][j] = grid[j][i];",
			"    }",
			"  }",
			"  return res;",
			"}"
		],
		"description": "Transpose Grid"
	},
	"Print Grid": {
		"prefix": "/printVector",
		"body": [
			"template <typename T>",
			"void print(const vector<T>& v, const string& sep = \"\\n\") {",
			"  for (auto& x : v) {",
			"    cout << x << sep;",
			"  }",
			"  cout.flush();",
			"}",
			" ",
			"template <typename T>",
			"void print(const vector<vector<T>>& v) {",
			"  for (auto& x : v) {",
			"    print(x, \"\");",
			"    cout << endl;",
			"  }",
			"  cout.flush();",
			"}"
		],
		"description": "Print Grid"
	},
	"64-bit bitset": {
		"prefix": "/Bitset64",
		"body": [
			"#include <string>",
			"#include <bits/functexcept.h>",
			"#include <iosfwd>",
			"#include <bits/cxxabi_forced.h>",
			"#include <bits/functional_hash.h>",
			"",
			"#pragma push_macro(\"__SIZEOF_LONG__\")",
			"#pragma push_macro(\"__cplusplus\")",
			"#define __SIZEOF_LONG__ __SIZEOF_LONG_LONG__",
			"#define unsigned unsigned long",
			"#define __cplusplus 201102L",
			"",
			"#define __builtin_popcountl __builtin_popcountll",
			"#define __builtin_ctzl __builtin_ctzll",
			"",
			"#include <bitset>",
			"",
			"#pragma pop_macro(\"__cplusplus\")",
			"#pragma pop_macro(\"__SIZEOF_LONG__\")",
			"#undef unsigned",
			"#undef __builtin_popcountl",
			"#undef __builtin_ctzl"
		],
		"description": "64-bit bitset"
	},
	"Template": {
		"prefix": "/Template",
		"body": [
			"#ifndef Local",
			"#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math,O3\")",
			"#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx\")",
			"#endif",
			"",
			"#include <bits/stdc++.h>",
			"",
			"#include <ext/numeric>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"using namespace __gnu_pbds;",
			"using namespace __gnu_cxx;",
			"using namespace std;",
			"",
			"#define popCnt(x) (__builtin_popcountll(x))",
			"#define sz(x) ((int)(x.size()))",
			"#define all(v) begin(v), end(v)",
			"typedef long long Long;",
			"typedef double Double;",
			"",
			"template <class T>",
			"istream& operator>>(istream& is, vector<T>& v) {",
			"  for (auto& x : v) {",
			"    is >> x;",
			"  }",
			"  return is;",
			"}",
			"",
			"template <class T>",
			"ostream& operator<<(ostream& os, vector<T>& v) {",
			"  for (auto& x : v) {",
			"    os << x << \" \";",
			"  }",
			"  return os;",
			"}",
			"",
			"int main() {",
			"  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
			"#ifdef Local",
			"  freopen(\"test.in\", \"r\", stdin);",
			"#else",
			"#define endl '\\n'",
			"#endif",
			"",
			"  return 0;",
			"}"
		],
		"description": "Template"
	},
	"Allocator": {
		"prefix": "/allocator",
		"body": [
			"static char buf[50 << 20];",
			"static size_t last_size = 0;",
			"static size_t buf_nxt = sizeof buf;",
			"",
			"void *operator new(size_t s) {",
			"  last_size = s;",
			"  return (void *)&buf[buf_nxt -= s];",
			"}",
			"",
			"void operator delete(void *ptr) {",
			"  if (ptr == ((void *)&buf[buf_nxt])) {",
			"    buf_nxt += last_size;",
			"  }",
			"}"
		],
		"description": "Allocator"
	},
	"Fractions": {
		"prefix": "/Fractions",
		"body": [
			"",
			"__int128 abs(__int128 x) {",
			"  if (x < 0) return -x;",
			"  return x;",
			"}",
			"",
			"template <typename Long>",
			"struct Fraction {",
			"  Long num = 0, den = 1;",
			"  Fraction(Long num = 0, Long den = 1) : num(num), den(den) { normalize(); }",
			"  void normalize() {",
			"    Long g = __gcd(num, den);",
			"    num /= g, den /= g;",
			"  }",
			"  Fraction operator*(const Fraction& other) const {",
			"    Fraction res = other;",
			"    res.num *= num;",
			"    res.den *= den;",
			"    res.normalize();",
			"    return res;",
			"  }",
			"  Fraction operator/(const Fraction& other) const {",
			"    return (*this) * Fraction(other.den, other.num);",
			"  }",
			"  Fraction operator+(const Fraction& other) const {",
			"    Fraction res = other;",
			"    Long lcm = res.den / __gcd(res.den, den) * den;",
			"    res.num *= lcm / res.den;",
			"    res.num += lcm / den * num;",
			"    res.den = lcm;",
			"    res.normalize();",
			"    return res;",
			"  }",
			"  Fraction operator-(const Fraction& other) const {",
			"    Fraction res = other * Fraction(-1);",
			"    return (*this) + res;",
			"  }",
			"  bool operator==(const Fraction& other) const {",
			"    // Must be normalized.",
			"    return num == other.num && den == other.den;",
			"  }",
			"",
			"  bool isNegative() const { return (num < 0) ^ (den < 0); }",
			"",
			"  bool operator<(const Fraction& other) const {",
			"    if ((*this) == other) return false;",
			"    if (den == 0) return false;",
			"    if (other.den == 0) return true;",
			"    if (isNegative() && !other.isNegative()) return true;",
			"    if (!isNegative() && other.isNegative()) return false;",
			"    if (isNegative() && other.isNegative())",
			"      return other * Fraction(-1) < (*this) * Fraction(-1);",
			"",
			"    // Uncomment this if it's possible to overflow.",
			"",
			"    // if (num / den > other.num / other.den) return false;",
			"    // if (num / den < other.num / other.den) return true;",
			"",
			"    // Fraction a = Fraction(den, num % den);",
			"    // Fraction b = Fraction(other.den, other.num % other.den);",
			"",
			"    // return b < a;",
			"",
			"    return num * other.den < den * other.num;",
			"  }",
			"  friend Fraction abs(const Fraction& x) {",
			"    Fraction res = x;",
			"    res.num = abs(res.num), res.den = abs(res.den);",
			"    return res;",
			"  }",
			"",
			"  friend ostream& operator<<(ostream& os, const Fraction& f) {",
			"    return os << f.num << \"/\" << f.den << \" : \" << fixed << setprecision(30)",
			"              << 1.0L * f.num / f.den;",
			"  }",
			"};",
			"",
			"istream& operator>>(istream& is, __int128& n) {",
			"  Long x;",
			"  is >> x;",
			"  n = x;",
			"  return is;",
			"}",
			"",
			"typedef Fraction<__int128> Fract;"
		],
		"description": "Fractions"
	},
	"Build Smallest Prime[N]": {
		"prefix": "/buildSmallestPrime",
		"body": [
			"int smallest_prime[N];",
			"",
			"void buildSmallestPrime() {",
			"  for (int i = 2; i < N; ++i) {",
			"    if (smallest_prime[i] != 0) {",
			"      continue;",
			"    }",
			"    smallest_prime[i] = i;",
			"    if (i > N / i) continue;",
			"    for (int j = i * i; j < N; j += i) {",
			"      if (smallest_prime[j] == 0) smallest_prime[j] = i;",
			"    }",
			"  }",
			"}"
		],
		"description": "Build Smallest Prime[N]"
	},
	"Euler Walk": {
		"prefix": "/eulerWalk",
		"body": [
			"// From kactl with minor changes.",
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2019-12-31",
			" * License: CC0",
			" * Source: folklore",
			" * Description: Eulerian undirected/directed path/cycle algorithm.",
			" * Input should be a vector of (dest, global edge index), where",
			" * for undirected graphs, forward/backward edges have the same index.",
			" * Returns a list of pairs of the nodes in the Eulerian path/cycle with src at",
			" * both start and end, and the edge indices, or empty list if no cycle/path",
			" * exists. Time: O(V + E) Status: stress-tested",
			" */",
			"",
			"vector<pii> eulerWalk(const vector<vector<pii>>& gr, int nedges, int src = -1) {",
			"  int n = sz(gr);",
			"  if (src == -1) {",
			"    // Find a non-isolated node.",
			"    src = find_if(all(gr), [](const vector<pii>& v) { return !v.empty(); }) -",
			"          begin(gr);",
			"    if (src == n) return {};",
			"  }",
			"",
			"  vi D(n), its(n), eu(nedges);",
			"  vector<pii> s = {make_pair(src, -1)};",
			"  vector<pii> ret;",
			"  D[src]++;  // to allow Euler paths, not just cycles",
			"  while (!s.empty()) {",
			"    auto x = s.back();",
			"    int y, e, &it = its[x.first], end = sz(gr[x.first]);",
			"    if (it == end) {",
			"      ret.emplace_back(x);",
			"      s.pop_back();",
			"      continue;",
			"    }",
			"    tie(y, e) = gr[x.first][it++];",
			"    if (!eu[e]) {",
			"      D[x.first]--, D[y]++;",
			"      eu[e] = 1;",
			"      s.emplace_back(y, e);",
			"    }",
			"  }",
			"  for (int x : D)",
			"    if (x < 0) return {};",
			"  if (sz(ret) != nedges + 1) return {};",
			"  reverse(all(ret));",
			"  return ret;",
			"}"
		],
		"description": "Euler Walk"
	},
	"Mex Of a Vector": {
		"prefix": "/mex",
		"body": [
			"int getMex(vector<int> v) {",
			"  sort(v.rbegin(), v.rend());",
			"  int res = 1;",
			"  while (!v.empty() && v.back() <= res) {",
			"    res += (v.back() == res);",
			"    v.pop_back();",
			"  }",
			"  return res;",
			"}"
		],
		"description": "Mex Of a Vector"
	}
}
